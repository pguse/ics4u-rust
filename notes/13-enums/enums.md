# Enums

[Structs](/notes/07-structs/structs.md) and enums have a similar syntax and are easiest to learn together.  Because they look similar, sometimes it is confuse them.

The main difference between [structs](/notes/07-structs/structs.md)  and enums is this:

-  if you have a lot of things to group together, that's a struct (short for Structure).
- But if you have a lot of choices and need to select one, that's an enum (short for Enumeration).

# Example - Book

If a book were a struct, it would have a

- title (that's a String),
- author_name (also a String), and a
- date_of_publication (maybe an i32).

But it also has more than one format: you need to choose to buy it either as paper or as an ebook. That's an enum.

# Example - Robot

Here is some starting code from our Robot project

```rust
enum Direction {
    North,
    East,
    South,
    West,
}

struct Robot {
    x: i32,
    y: i32,
    direction: Direction,
}

impl Robot {
    fn new(x: i32, y: i32, direction: Direction) -> Self {
        Robot {
            x,
            y,
            direction,
        }
    }

    fn turn_right(&mut self) {
        self.direction = match self.direction {
            Direction::North => Direction::East,
            Direction::East => Direction::South,
            Direction::South => Direction::West,
            Direction::West => Direction::North,
        };
    }
}

fn main() {
    let mut robot = Robot::new(7, 3, Direction::North);
    robot.turn_right();
    println!("Position {:?} Facing {:?}", robot.position(), robot.direction());
```

The direction of the Robot is described using an **enum** because the robot only turns through right angles, and is therefore only facing `North`, `East`, `South`, or `West`. Since, there are only 4 possible choices for direction, an **enum** is appropriate as a data type.  Since the robot has different **attributes** _(position and direction)_, a  [struct](/notes/07-structs/structs.md) is an appropriate data type.

The use of an **enum** is advantageous when using `match` statements, because when using `match` all options must be dealt with _(unlike with an if-statement)_ or the compiler will generate an error. The **enum** data type indicates all the possible options, so there is no need to handle a default option.

## Traits

If you run the code above, you will notice that an error will be generated by the compiler.  You'll see a message like this,

`Direction` cannot be formatted using `{:?}` because it doesn't implement `Debug`

As with a [struct](/notes/07-structs/structs.md) , the Rust compiler does not know how to output an **enum** since it is a custom data type.  You must implement the `Debug` trait explicitly as follows

```rust
#[derive(Debug)]
enum Direction {
    North,
    East,
    South,
    West,
}
```

Now the code should run without error.

# Example - An Enum that holds data

In Rust, you can think of **enums** as a way to define a type by enumerating its possible variants, each of which can optionally store associated data.

Here's an example to illustrate:

```rust
enum Message {
    Quit,                       // No associated data
    Move { x: i32, y: i32 },    // Named fields
    Write(String),              // Single unnamed value
    ChangeColor(i32, i32, i32), // Multiple unnamed values
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from("Hello"));
    let msg4 = Message::ChangeColor(255, 0, 0);
    
    // Handle the different variants using a match expression
    match msg3 {
        Message::Quit => println!("Quit variant"),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(text) => println!("Message: {}", text),
        Message::ChangeColor(r, g, b) => println!("Change color to RGB({}, {}, {})", r, g, b),
    }
}
```

In this example:
- `Message::Quit` is a variant with no associated data.
- `Message::Move` is a variant with named fields `x` and `y`.
- `Message::Write` is a variant with a single unnamed value of type `String`.
- `Message::ChangeColor` is a variant with multiple unnamed values of type `i32`.

Using `match` expressions, you can handle each variant and access their associated data.

Enums are particularly useful for defining types that can have different kinds of data and behavior, all within the same type.

# Overview

- Use a [struct](/notes/07-structs/structs.md)  when you want one thing AND another thing.
- Use an enum when you want one thing OR another thing.

So [structs](/notes/07-structs/structs.md)  are for **many things together**, while **enums** are for **many possible choices**.

To declare an **enum**, write `enum` and use a code block with the options, separated by commas.